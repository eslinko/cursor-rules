# Hard Analysis Rules for Code Study, Documentation, and Roadmap Planning

## Core Principles

1. **Analyze only real code** - no assumptions, no speculation, no fantasies
2. **Verify every statement** - if you can't find it in code, don't write it
3. **Ask questions when unclear** - better to ask than to invent
4. **Use grep/search** to find real usage of functions/classes
5. **Read complete files** when necessary, don't limit to first lines
6. **Cross-reference** between different parts of the codebase
7. **Validate dependencies** and relationships through actual code paths
8. **Integrate rather than duplicate** - extend existing rules instead of creating parallel ones
9. **Maintain single source of truth** - each concept in one logical place
10. **Progressive enhancement** - build upon existing knowledge without replacement

## Analysis Algorithm

### 1. Configuration Analysis
- Find all configuration files (`config.*`, `*.env`, `*.yml`, `*.json`, `*.properties`, `*.ini`, `*.toml`)
- Check real environment variables through `grep_search`
- Compare with documentation claims
- If mismatch found - fix documentation
- **Path consistency validation**: Audit ALL hardcoded paths and references in the codebase
- **Structure integrity**: Ensure path consistency across all related components
- **Resource location verification**: Validate that resources are created/accessed in correct locations

### 2. Architecture Analysis
- Map all services/modules in the codebase
- Check real dependencies through `read_file`
- Verify described relationships between components
- Confirm actual usage of patterns (singletons, factories, etc.)
- **Change propagation validation**: Explicitly enumerate ALL affected files when making structural changes
- **Compatibility verification**: Validate compatibility between old and new implementations
- **Legacy pattern identification**: Find and document outdated patterns that need migration

### 3. API/Interface Analysis
- Find all routes/endpoints/controllers in relevant directories
- Check real dependency injection through `grep_search`
- Verify described service connections
- Validate middleware and authentication flows

### 4. Data Flow Analysis
- Trace data through the system
- Check real method signatures and return types
- Verify described contracts and interfaces
- Validate actual transactions and calls
- **Multi-stage process validation**: Test data compatibility between consecutive stages
- **Integration contracts**: Verify that Stage N output matches Stage N+1 input expectations
- **End-to-end validation**: Test complete data flow through all processing stages

### 5. Model/Data Structure Analysis
- Find all models/entities/classes in the codebase
- Check real fields/properties and methods
- Verify described validations
- Confirm actual data types

## Critical Verification Commands

### For Configuration Analysis:
```bash
# Always check real variables
grep_search "VARIABLE_NAME" include_pattern="*config*"
grep_search "VARIABLE_NAME" include_pattern="*.env"
read_file target_file="config.*" should_read_entire_file=True
read_file target_file="*.yml" should_read_entire_file=True
read_file target_file="*.json" should_read_entire_file=True
```

### For Architecture Analysis:
```bash
# Check real dependencies
grep_search "import.*Service" include_pattern="**/*"
grep_search "Service.*Depends" include_pattern="**/*"
grep_search "require.*Service" include_pattern="**/*"
grep_search "inject.*Service" include_pattern="**/*"
```

### For API/Interface Analysis:
```bash
# Check real routes/endpoints
list_dir relative_workspace_path="api/"
list_dir relative_workspace_path="routes/"
list_dir relative_workspace_path="controllers/"
list_dir relative_workspace_path="handlers/"
read_file target_file="**/routes/*" start_line_one_indexed=1 end_line_one_indexed=50
read_file target_file="**/controllers/*" start_line_one_indexed=1 end_line_one_indexed=50
```

### For Service/Component Analysis:
```bash
# Check real methods/functions
grep_search "function.*method_name" include_pattern="**/*"
grep_search "def.*method_name" include_pattern="**/*"
grep_search "public.*method_name" include_pattern="**/*"
grep_search "private.*method_name" include_pattern="**/*"
read_file target_file="**/services/*" start_line_one_indexed=1 end_line_one_indexed=100
read_file target_file="**/components/*" start_line_one_indexed=1 end_line_one_indexed=100
```

## Prohibited Actions

‚ùå **NO assumptions** - if not visible in code, don't write it
‚ùå **NO speculation** - verify every claim
‚ùå **NO copying** from other projects - analyze only this codebase
‚ùå **NO generic templates** - describe specific implementation
‚ùå **NO ignoring discrepancies** - fix inconsistencies when found
‚ùå **NO pattern matching** without verification - check actual implementation
‚ùå **NO duplication** - integrate new rules into existing structure instead of creating parallel sections
‚ùå **NO fragmentation** - maintain single source of truth for each concept
‚ùå **NO replacement** - enhance existing knowledge rather than replacing it

## Required Questions When Uncertain

1. **"Where is this implemented in code?"** - if you can't find it
2. **"How does this actually work?"** - if you only see interface
3. **"What are the real dependencies?"** - if described connections seem assumed
4. **"What's the actual data format?"** - if described structures seem assumed
5. **"Is this the current state or planned?"** - distinguish between existing and TODO
6. **"Does this duplicate existing rules?"** - check for overlap before adding new content
7. **"Can this be integrated into existing structure?"** - prefer enhancement over parallel creation
8. **"Where is the logical home for this concept?"** - find the most relevant existing section

## Documentation Verification Template

### For each documentation section:
1. **Find corresponding code** in the project
2. **Check real implementation** through `read_file`
3. **Compare with documentation** - what matches, what doesn't
4. **Fix discrepancies** through `search_replace`
5. **Add real examples** from code
6. **Remove fantasies** - keep only facts

### For each claim:
- ‚úÖ **Confirmed by code** - can keep
- ‚ùå **Not found in code** - must remove or fix
- ‚ùì **Unclear** - need to ask question or investigate deeper

## Roadmap Planning Analysis

### Current State Assessment:
1. **Map existing functionality** through code analysis
2. **Identify actual dependencies** between components
3. **Document real technical debt** found in code
4. **List actual TODO comments** and incomplete features
5. **Assess real complexity** through code structure
6. **Distinguish implementation states**: "not implemented" vs "implemented incorrectly"
7. **Verify actual functionality**: Test component behavior, not just existence
8. **Validate component state**: Ensure components function as intended

### Gap Analysis:
1. **Compare requirements** with actual implementation
2. **Identify missing components** through dependency analysis
3. **Document integration points** that need work
4. **Assess scalability bottlenecks** in current architecture

## Final Verification Checklist

After each documentation/analysis update:
1. **Re-read modified sections**
2. **Verify code compliance** again
3. **Ensure no fantasies remain**
4. **Confirm all examples are real**
5. **Check for consistency** across related sections
6. **Explicit change specifications**: Detail exact changes required in each component
7. **Concrete examples**: Provide before/after examples for all modifications
8. **Validation criteria**: Include testable requirements for successful implementation

## Key Analysis Commands

```bash
# Usage search
grep_search query="ClassName" include_pattern="**/*"
grep_search query="class ClassName" include_pattern="**/*"
grep_search query="interface ClassName" include_pattern="**/*"

# File reading
read_file target_file="path/to/file.*" should_read_entire_file=False start_line_one_indexed=1 end_line_one_indexed=100

# Structure exploration
list_dir relative_workspace_path="path/to/directory"

# File discovery
file_search query="filename"

# Cross-reference
grep_search query="function_name" include_pattern="**/*"
grep_search query="method_name" include_pattern="**/*"
grep_search query="procedure_name" include_pattern="**/*"
```

## Context-Specific Rules

### For Code Study:
- Focus on understanding actual implementation
- Map real relationships between components
- Document actual patterns used
- Identify real complexity and bottlenecks

### For Documentation:
- Base all descriptions on actual code
- Include real examples from codebase
- Document actual configuration and setup
- Show real usage patterns

### For Roadmap Planning:
- Assess current state through code analysis
- Identify real technical debt
- Map actual dependencies and integration points
- Plan based on real complexity, not assumptions

## Quality Gates

Before considering analysis complete:
- [ ] All claims verified against actual code
- [ ] No assumptions or speculations remain
- [ ] All examples are real and testable
- [ ] Dependencies accurately mapped
- [ ] Configuration correctly documented
- [ ] Architecture relationships validated

These rules ensure that all analysis, documentation, and planning are based solely on real code without fantasies or assumptions.

---

## üö® UNIVERSAL SYSTEM PATTERNS

### **Universal Anti-Patterns to Avoid**

‚ùå **Architectural Drift**: Changes implemented inconsistently across system components
‚ùå **Path Fragmentation**: Hardcoded paths scattered throughout codebase
‚ùå **Integration Gaps**: Stages developed in isolation without compatibility validation
‚ùå **State Misassessment**: Planning based on assumed rather than verified component state
‚ùå **Vague Communication**: Ambiguous change descriptions without concrete specifications
‚ùå **Legacy Accumulation**: Old patterns coexisting with new implementations
‚ùå **Contract Violations**: Data format mismatches between system components

### **Universal Success Patterns**

‚úÖ **Systematic Propagation**: All changes consistently applied across affected components
‚úÖ **Path Abstraction**: Centralized path management with consistent access patterns
‚úÖ **Contract-Driven Development**: Clear data contracts between all system stages
‚úÖ **Verified State Planning**: Development based on tested component functionality
‚úÖ **Explicit Change Specifications**: Concrete, testable requirements for all modifications
‚úÖ **Integration-First Design**: Compatibility validation built into development process
‚úÖ **Legacy Management**: Systematic identification and migration of outdated patterns
‚úÖ **Knowledge Integration**: Extending existing rules rather than creating parallel ones
‚úÖ **Single Source of Truth**: Each concept maintained in one logical location
‚úÖ **Progressive Enhancement**: Building upon existing knowledge without replacement

### **Enhanced Analysis Commands**

```bash
# Change propagation validation
grep_search query="old_pattern|legacy|deprecated" include_pattern="**/*"  # Find outdated patterns
grep_search query="new_pattern" include_pattern="**/*"  # Verify new implementations

# Path and structure consistency checks
grep_search query="hardcoded_path|absolute_path" include_pattern="**/*"  # Find hardcoded paths
grep_search query="\.\.\/|\.\/" include_pattern="**/*"  # Find relative path references

# Multi-stage process validation
read_file target_file="stage_output.*" should_read_entire_file=True  # Examine stage outputs
grep_search query="input.*format|output.*format" include_pattern="**/*"  # Find data contracts

# State assessment commands
grep_search query="TODO|FIXME|HACK|BUG|BROKEN" include_pattern="**/*"  # Find incomplete work
grep_search query="not.*implemented|placeholder|stub" include_pattern="**/*"  # Find incomplete features

# Integration compatibility checks
grep_search query="interface|contract|schema" include_pattern="**/*"  # Find data contracts
grep_search query="validate|check|verify" include_pattern="**/*"  # Find validation logic
```

These universal patterns ensure robust system analysis that prevents architectural inconsistencies, integration failures, and development inefficiencies across any type of software project.
description:
globs:
alwaysApply: false
---
